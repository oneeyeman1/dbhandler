// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Sat Jan 04 11:51:25 2020
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#include "wx/mdi.h"
#endif

#include "wx/listctrl.h"
#include "wx/dataview.h"
#include "wx/renderer.h"
#include "database.h"
#include "sortgroupbypage.h"

const wxEventTypeTag<wxCommandEvent> wxEVT_CHANGE_QUERY( wxEVT_USER_FIRST + 3 );

#ifdef __WXGTK__
/* handdrag.cur - 326 bytes */
static const unsigned char handdrag[] = {

    0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x20, 0x20, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x30, 0x01,
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x3f,
    0xf8, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x7f,
    0xfc, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x00, 0xff,
    0xfc, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x3f, 0xec, 0x00, 0x00, 0x3f,
    0x6c, 0x00, 0x00, 0x3f, 0x6c, 0x00, 0x00, 0x3b, 0x6c, 0x00, 0x00, 0x1b, 0x68, 0x00, 0x00, 0x1b,
    0x60, 0x00, 0x00, 0x1b, 0x60, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x18,
    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18,
    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x07, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0x80,
    0x03, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0x00,
    0x01, 0xff, 0xff, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xfe, 0x00,
    0x01, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0x80,
    0x01, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xc0, 0x01, 0xff, 0xff, 0xc0,
    0x03, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xc0,
    0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xc3,
    0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xfc, 0x00,
    0x3f, 0xff, 0xfe, 0x00, 0x7f, 0xff
};

#endif

#ifdef __WXMSW__
bool MyListCtrl::MSWOnNotify (int idCtrl, WXLPARAM lParam, WXLPARAM *result)
{
    NMHDR *nmhdr = (NMHDR *)lParam;
    switch ( nmhdr->code )
    {
        case LVN_HOTTRACK:
        {
            NMLISTVIEW *l = (NMLISTVIEW *)lParam;
            l->iItem = -1;
            return 0;
        }
    }
    return wxListCtrl::MSWOnNotify( idCtrl, lParam, result );
}
#endif

wxSize MyListCtrl::DoGetBestClientSize () const
{
    wxClientDC dc( const_cast<MyListCtrl*>( this ) );
    return wxSize( 50 * dc.GetCharWidth(), 5 * dc.GetCharHeight() );
}

SortColumnRenderer::SortColumnRenderer(wxCheckBoxState state, wxDataViewCellMode mode, int align)
    : wxDataViewCustomRenderer( GetDefaultType(), mode, align )
{
    m_toggle = true;
    m_allow3rdStateForUser = false;
}

bool SortColumnRenderer::SetValue(const wxVariant& value)
{
    m_toggle = value.GetBool();
    return true;
}

bool SortColumnRenderer::GetValue(wxVariant& value) const
{
    value = value;
    return true;
}

wxSize SortColumnRenderer::GetSize() const
{
    wxSize size = GetCheckSize();
    size.x += MARGIN_CHECK_ICON;

    const wxSize sizeText = GetTextExtent( _( "Ascending" ) );
    if( sizeText.y > size.y )
        size.y = sizeText.y;
    size.x += sizeText.x;
    return size;
}
#ifdef __WXMSW__
wxString SortColumnRenderer::GetAccessibleDescription() const
{
    /* TRANSLATORS: Checkbox state name */
    return m_toggle ? _("Sort Ascending")
        /* TRANSLATORS: Checkbox state name */
        : _("Sort descendending");
}
#endif
bool SortColumnRenderer::Render(wxRect cell, wxDC* dc, int state)
{
    // Draw the checkbox first.
    int flags = 0;
    if( m_toggle )
        flags |= wxCONTROL_CHECKED;
    if( GetMode() != wxDATAVIEW_CELL_ACTIVATABLE || !( GetOwner()->GetOwner()->IsEnabled() && GetEnabled() ) )
        flags |= wxCONTROL_DISABLED;

    if( state & wxDATAVIEW_CELL_PRELIT )
        flags |= wxCONTROL_CURRENT;

    const wxSize sizeCheck = GetCheckSize();
    wxRect rectCheck( cell.GetPosition(), sizeCheck );
    rectCheck = rectCheck.CentreIn( cell, wxVERTICAL );

    wxRendererNative::Get().DrawCheckBox( GetView(), *dc, rectCheck, flags );
    // Then the icon, if any.
    int xoffset = sizeCheck.x + MARGIN_CHECK_ICON;
    // Finally the text.
    RenderText( _( "Ascending" ), xoffset, cell, dc, state );
    return true;
}

bool SortColumnRenderer::ActivateCell (const wxRect& cell, wxDataViewModel *model, const wxDataViewItem & item, unsigned int col, const wxMouseEvent *mouseEvent)
{
    if( mouseEvent )
    {
        if( !wxRect( GetCheckSize() ).Contains( mouseEvent->GetPosition() ) )
            return false;
    }
    model->ChangeValue( !m_toggle, item, col );
    wxVariant temp;
    model->GetValue( temp, item, 0 );
    wxCommandEvent event( wxEVT_CHANGE_QUERY );
    event.SetEventObject( GetView()->GetParent() );
    event.SetInt( CHANGEFIELD );
    event.SetExtraLong( m_toggle ? ASCENDING : DESCENDING );
    event.SetString( temp.GetString() );
    GetView()->GetParent()->GetParent()->GetParent()->GetEventHandler()->ProcessEvent( event );
    return true;
}

wxIMPLEMENT_CLASS(SortColumnRenderer, wxDataViewCustomRenderer);

SortGroupByPage::SortGroupByPage(wxWindow *parent, bool isSortPage) : wxPanel( parent )
{
    m_isSorting = isSortPage;
    m_isDragging = false;
    m_dragDest = nullptr;
    m_label = new wxStaticText( this, wxID_ANY, _( "Drag and drop the columns in the order that you want them" ) );
    if( isSortPage )
    {
        m_sortSource = new wxDataViewListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxDV_SINGLE | wxDV_NO_HEADER );
        m_sortDest = new wxDataViewListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxDV_SINGLE | wxDV_NO_HEADER );
        m_source = nullptr;
        m_dest = nullptr;
    }
    else
    {
        m_source = new MyListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_NO_HEADER );
        m_dest = new MyListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_NO_HEADER );
        m_sortSource = nullptr;
        m_sortDest = nullptr;
    }
    set_properties();
    do_layout();
    if( m_source )
        m_source->SetColumnWidth( 0, m_source->GetClientSize().GetWidth() );
    if( m_dest )
        m_dest->SetColumnWidth( 0, m_dest->GetClientSize().GetWidth() );
    if( !isSortPage )
    {
        m_source->Bind( wxEVT_LIST_BEGIN_DRAG, &SortGroupByPage::OnBeginDrag, this );
        m_dest->Bind( wxEVT_LIST_BEGIN_DRAG, &SortGroupByPage::OnBeginDrag, this );
        m_source->Bind( wxEVT_LIST_ITEM_SELECTED, &SortGroupByPage::OnItemSelected, this );
        m_dest->Bind( wxEVT_LIST_ITEM_SELECTED, &SortGroupByPage::OnItemSelected, this );
        m_source->Bind( wxEVT_LIST_ITEM_FOCUSED, &SortGroupByPage::OnItemFocused, this );
        m_dest->Bind( wxEVT_LIST_ITEM_FOCUSED, &SortGroupByPage::OnItemFocused, this );
        Bind( wxEVT_LEFT_UP, &SortGroupByPage::OnLeftUp, this );
        Bind( wxEVT_MOUSE_CAPTURE_LOST, &SortGroupByPage::OnMouseCaptureLost, this );
    }
    else
    {
        m_sortSource->EnableDragSource( wxDF_UNICODETEXT );
        m_sortSource->EnableDropTarget( wxDF_UNICODETEXT );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_BEGIN_DRAG, &SortGroupByPage::OnSortBeginDrag, this );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_DROP, &SortGroupByPage::OnSortDrop, this );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_DROP_POSSIBLE, &SortGroupByPage::OnSortDropPossible, this );
        m_sortSource->Bind( wxEVT_DATAVIEW_SELECTION_CHANGED, &SortGroupByPage::OnSortSelectionChanged, this );
        m_sortSource->Bind( wxEVT_DATAVIEW_ITEM_START_EDITING, &SortGroupByPage::OnSortListStartEditing, this );
        m_sortDest->EnableDragSource( wxDF_UNICODETEXT );
        m_sortDest->EnableDropTarget( wxDF_UNICODETEXT );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_DROP, &SortGroupByPage::OnSortDrop, this );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_BEGIN_DRAG, &SortGroupByPage::OnSortBeginDrag, this );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_DROP_POSSIBLE, &SortGroupByPage::OnSortDropPossible, this );
        m_sortDest->Bind( wxEVT_DATAVIEW_SELECTION_CHANGED, &SortGroupByPage::OnSortSelectionChanged, this );
        m_sortDest->Bind( wxEVT_DATAVIEW_ITEM_START_EDITING, &SortGroupByPage::OnSortListStartEditing, this );
    }
}

SortGroupByPage::~SortGroupByPage()
{

}

void SortGroupByPage::set_properties()
{
    if( !m_isSorting )
    {
        m_source->InsertColumn( 0, _( "" ), wxLIST_FORMAT_LEFT, wxLIST_AUTOSIZE );
        m_source->SetCursor( wxCURSOR_HAND );
        m_dest->InsertColumn( 0, _( "" ), wxLIST_FORMAT_LEFT, wxLIST_AUTOSIZE );
        m_dest->SetCursor( wxCURSOR_HAND );
    }
    else
    {
        m_sortSource->AppendTextColumn( "" );
        m_sortSource->SetCursor( wxCURSOR_HAND );
        m_sortDest->AppendTextColumn( "", wxDATAVIEW_CELL_INERT, wxCOL_WIDTH_AUTOSIZE, wxALIGN_LEFT );
        m_sortDest->AppendColumn( new wxDataViewColumn( "", new SortColumnRenderer, 1, wxDVC_DEFAULT_WIDTH, wxALIGN_RIGHT ) );
        m_sortDest->SetCursor( wxCURSOR_HAND );
    }
}

void SortGroupByPage::do_layout()
{
    auto sizer1 = new wxBoxSizer( wxVERTICAL );
    auto sizer2 = new wxBoxSizer( wxHORIZONTAL );
    sizer1->Add( m_label, 0, wxEXPAND, 0 );
    sizer1->Add( 5, 5, 0, wxEXPAND, 0 );
    if( !m_isSorting )
    {
        sizer2->Add( m_source, 1, wxEXPAND, 0 );
        sizer2->Add( m_dest, 1, wxEXPAND, 0 );
    }
    else
    {
        sizer2->Add( m_sortSource, 1, wxEXPAND, 0 );
        sizer2->Add( m_sortDest, 1, wxEXPAND, 0 );
    }
    sizer1->Add( sizer2, 1, wxEXPAND, 0 );
    SetSizer( sizer1 );
}

wxListCtrl *SortGroupByPage::GetSourceList()
{
    return m_source;
}

wxListCtrl *SortGroupByPage::GetDestList()
{
    return m_dest;
}

wxDataViewListCtrl *SortGroupByPage::GetSortSourceList()
{
    return m_sortSource;
}

wxDataViewListCtrl *SortGroupByPage::GetSourceDestList()
{
    return m_sortDest;
}

void SortGroupByPage::OnBeginDrag(wxListEvent &event)
{
    int flags;
    const wxPoint& pt = event.m_pointDrag;
    wxListCtrl *list = nullptr;
    m_dragSource = dynamic_cast<MyListCtrl *>( event.GetEventObject() );
#ifdef __WXMSW__
    m_dragSource->SetCursor( wxCursor( "handdrag" ) );
#elif __WXOSX__
    m_dragSource->SetCursor( wxCursor( "handdrag" ) );
    if( m_dragSource == m_source )
        list = m_dest;
    else
        list = m_source;
    list->SetCursor( wxCursor( "handdrag" ) );
#else
	m_dragSource->SetCursor( wxCursor( (const char *) handdrag, 32, 32, 16, 0, nullptr, wxWHITE, wxBLACK ) );
    if( m_dragSource == m_source )
        list = m_dest;
    else
        list = m_source;
    list->SetCursor( wxCursor( (const char *) handdrag, 32, 32, 16, 0, nullptr, wxWHITE, wxBLACK ) );
#endif
    if( m_dragSource == m_source )
        m_itemPos = m_dragSource->HitTest( pt, flags );
    else
    {
        m_sourcePos = m_dragSource->HitTest( pt, flags );
        m_itemPos = m_dragSource->GetItemData( m_dragSource->HitTest( pt, flags ) );
    }
    m_item = m_dragSource->GetItemText( m_dragSource->HitTest( pt, flags ) );
    m_dragSource->SetItemState( m_dragSource->HitTest( pt, flags ), 0, wxLIST_STATE_SELECTED );
    m_dragSource->SetItemState( m_dragSource->HitTest( pt, flags ), 0, wxLIST_STATE_FOCUSED );
    m_isDragging = true;
    this->CaptureMouse();
}

void SortGroupByPage::OnItemSelected(wxListEvent &event)
{
    wxListCtrl *list = dynamic_cast<wxListCtrl *>( event.GetEventObject() );
    if( list )
        list->SetItemState( event.GetIndex(), 0, wxLIST_STATE_SELECTED );
}

void SortGroupByPage::OnItemFocused(wxListEvent &event)
{
    wxListCtrl *list = dynamic_cast<wxListCtrl *>( event.GetEventObject() );
    if( list )
        list->SetItemState( event.GetIndex(), 0, wxLIST_STATE_FOCUSED );
}

void SortGroupByPage::OnLeftUp(wxMouseEvent &event)
{
    const wxPoint pt = event.GetPosition();
    m_dragSource->SetCursor( wxCURSOR_HAND );
#ifndef __WXMSW__
    wxListCtrl *list = nullptr;
    if( m_dragSource == m_source )
        list = m_dest;
    else
        list = m_source;
    list->SetCursor( wxCursor( wxCURSOR_HAND ) );
#endif
    if( m_source->GetRect().Contains( pt ) )
        m_dragDest = m_source;
    else if( m_dest->GetRect().Contains( pt ) )
        m_dragDest = m_dest;
    if( ( m_dragSource == m_dragDest && ( m_dragSource == m_source && m_dragDest == m_source ) ) || ( ( m_dragSource == m_dest && m_dragDest == m_dest  && m_dest->GetItemCount() == 1 ) ) )
    {
        ReleaseMouse();
        event.Skip();
        return;
    }
    FinishDragging( pt );
    event.Skip();
}

void SortGroupByPage::FinishDragging(const wxPoint &pt)
{
    long position= 0;
    Positions positions;
    if( m_isDragging )
    {
        if( m_dragDest != m_source && m_dragDest != m_dest && m_dragSource == m_source )
            return;
        if( m_dragDest != m_source && m_dragDest != m_dest && m_dragSource == m_dest )
            m_dragDest = m_source;
        m_dragDest->SetCursor( wxCURSOR_HAND );
//        if( m_dragSource != m_dragDest )
        {
            int flags;
            long pos = 0;
            if( m_dragDest == m_dest )
            {
                position = m_source->GetItemData( m_itemPos );
                positions.originalPosition = position;
            }
            else
            {
                pos = m_dragSource->GetItemData( m_sourcePos );
                positions.originalPosition = pos;
            }
            m_dragSource->DeleteItem( m_dragDest == m_dest ? m_itemPos : m_sourcePos );
            if( m_dragDest == m_dest )
            {
                pos = m_dragDest->HitTest( m_dragDest->ScreenToClient( ClientToScreen( pt ) ), flags );
                if( pos == wxNOT_FOUND )
                    pos = m_dragDest->GetItemCount();
            }
            long item = m_dragDest->InsertItem( pos, m_item );
            if( m_dragDest == m_dest )
            {
                m_dragDest->SetItemData( item, position );
            }
            else
                m_dragDest->SetItemData( item, pos );
            positions.position = pos;
            wxCommandEvent event( wxEVT_CHANGE_QUERY );
            event.SetEventObject( this );
            event.SetInt( m_dragDest == m_source ? REMOVEFIELD : m_dragSource == m_source ? ADDFIELD : CHANGEFIELD );
            event.SetClientData( &positions );
            event.SetString( m_item );
            GetParent()->GetParent()->GetEventHandler()->ProcessEvent( event );
        }
        this->ReleaseMouse();
        m_isDragging = false;
        m_dragDest = nullptr;
    }
}

void SortGroupByPage::OnMouseMove(wxMouseEvent &event)
{
    wxListCtrl *list = nullptr;
    int flags;
    const wxPoint& pt = event.GetPosition();
    if( m_source->GetRect().Contains( pt ) )
        list = m_source;
    else if( m_dest->GetRect().Contains( pt ) )
        list = m_dest;
    if( list && !m_isDragging )
    {
        long pos = list->HitTest( pt, flags );
        if( pos != wxNOT_FOUND && list->GetItemState( pos, wxLIST_STATE_FOCUSED ) )
            list->SetItemState( pos, 0, wxLIST_STATE_FOCUSED );
    }
    if( m_isDragging )
        event.Skip();
}

void SortGroupByPage::OnMouseCaptureLost(wxMouseCaptureLostEvent &WXUNUSED(event))
{
}

void SortGroupByPage::AddRemoveSortingField(bool isAdding, const wxString &field)
{
    wxVector<wxVariant> data;
    if( isAdding )
    {
        data.push_back( wxVariant( field ) );
        m_sortSource->AppendItem( data );;
    }
}

void SortGroupByPage::OnSortBeginDrag(wxDataViewEvent &event)
{
    m_draggedItem = event.GetItem();
    wxVariant value = event.GetValue();
    m_sortDragSource = dynamic_cast<wxDataViewListCtrl *>( event.GetEventObject() );
#ifdef __WXMSW__
    m_sortDragSource->SetCursor( wxCursor( "handdrag" ) );
#elif __WXOSX__
    m_sortDragSource->SetCursor( wxCursor( "handdrag" ) );
#else
    m_sortDragSource->SetCursor( wxCursor( (const char *) handdrag, 32, 32, 16, 0, nullptr, wxWHITE, wxBLACK ) );
#endif
    if( m_sortDragSource == m_sortSource && m_draggedItem.IsOk())
        m_itemPos = m_sortDragSource->ItemToRow( m_draggedItem );
    else if( m_draggedItem.IsOk() )
    {
        m_sourcePos = m_sortDragSource->ItemToRow( m_draggedItem );
        m_itemPos = m_sortDragSource->GetItemData( m_draggedItem );
    }
    m_item = m_sortDragSource->GetTextValue( m_sortDragSource->ItemToRow( m_draggedItem ), 0 );
    if( m_sortDragSource == m_sortDest )
    {
        m_sortDest->GetValue( value, m_sortDest->ItemToRow( m_draggedItem), 1 );
//        m_item += value.GetBool() ? " ASC" : " DESC";
    }
    wxTextDataObject *obj = new wxTextDataObject;
    obj->SetText( m_item );
    event.SetDataObject( obj );
    event.SetDragFlags( wxDrag_CopyOnly );
    m_isDragging = true;
}

void SortGroupByPage::OnSortDrop(wxDataViewEvent &event)
{
    long pos = 0, position = 0;
    Positions positions;
    wxVariant value = event.GetValue();
    m_sortDragDest = dynamic_cast<wxDataViewListCtrl *>( event.GetEventObject() );
    m_sortDragSource->SetCursor( wxCURSOR_HAND );
    if( m_sortDragSource != m_sortDragDest )
    {
        if( m_sortDragSource == m_sortSource )
        {
            position = m_itemPos;
            positions.originalPosition = position;
        }
        else
        {
            pos = m_sortDragSource->GetItemData( m_draggedItem );
            positions.originalPosition = pos;
        }
        m_sortDragSource->DeleteItem( m_sortDragDest == m_sortDest ? m_itemPos : m_sourcePos );
        if( m_sortDragDest == m_sortDest )
        {
            wxDataViewItem dropItem;
            wxDataViewColumn *dropCol;
            m_sortDest->HitTest( event.GetPosition(), dropItem, dropCol );
            wxVector<wxVariant> data;
            data.push_back( m_item );
            data.push_back( (wxVariant) true );
            wxDataViewItem  item = event.GetItem();
            if( !item.IsOk() )
            {
                pos = m_sortDragDest->GetItemCount();
                m_sortDragDest->AppendItem( data );
            }
            else
            {
                pos = m_sortDest->ItemToRow( item );
                m_sortDest->InsertItem( pos, data );
            }
            m_sortDragDest->SetItemData( m_sortDragDest->RowToItem( pos ), m_itemPos );
        }
        else
        {
            wxVector<wxVariant> data;
            data.push_back( m_item );
            position = m_itemPos;
            int count = m_sortDragDest->GetItemCount();
            if( position > count )
                position = count;
            m_sortDragDest->InsertItem( position, data );
        }
    }
    positions.position = pos;
    wxCommandEvent evt( wxEVT_CHANGE_QUERY );
    evt.SetEventObject( this );
    evt.SetClientData( &positions );
    evt.SetString( m_item );
    evt.SetInt( m_sortDragDest == m_sortSource ? REMOVEFIELD : m_sortDragSource == m_sortSource ? ADDFIELD : CHANGEFIELD );
    if( m_sortDragDest != m_sortDest )
    {

    }
    evt.SetString( m_item );
    GetParent()->GetParent()->GetEventHandler()->ProcessEvent( evt );
    m_isDragging = false;
    m_dragDest = nullptr;
}

void SortGroupByPage::OnSortDropPossible(wxDataViewEvent &event)
{
    event.Allow();
}

void SortGroupByPage::OnSortSelectionChanged(wxDataViewEvent &event)
{
    wxDataViewListCtrl *object = dynamic_cast<wxDataViewListCtrl *>( event.GetEventObject() );
    object->Unselect( event.GetItem() );
}

void SortGroupByPage::OnSortListStartEditing(wxDataViewEvent &event)
{
    if( ( event.GetEventObject() == m_sortSource || event.GetEventObject() == m_sortDest ) && event.GetColumn() == 0 )
        event.Veto();
}

void SortGroupByPage::RemoveTable(const wxString tbl)
{
    if( m_sortSource )
    {
        auto itemSource = m_sortSource->GetItemCount();
        while( itemSource > 0 )
        {
            auto field = m_sortSource->GetTextValue( itemSource - 1, 0 );
            if( field.find( tbl ) != -1 )
                m_sortSource->DeleteItem( itemSource - 1 );
            itemSource--;
        }
        auto itemDest = m_sortDest->GetItemCount();
        while( itemDest > 0 )
        {
            auto field = m_sortDest->GetTextValue( itemDest - 1, 0 );
            if( field.find( tbl ) != -1 )
                m_sortDest->DeleteItem( itemDest - 1 );
            itemDest--;
        }
    }
    if( m_source )
    {
        auto itemSource = m_source->GetItemCount();
        while( itemSource > 0 )
        {
            auto field = m_source->GetItemText( itemSource - 1, 0 );
            if( field.find( tbl ) != -1 )
                m_source->DeleteItem( itemSource - 1 );
            itemSource--;
        }
        auto itemDest = m_dest->GetItemCount();
        while( itemDest > 0 )
        {
            auto field = m_dest->GetItemText( itemDest - 1, 0 );
            if( field.find( tbl ) != -1 )
                m_dest->DeleteItem( itemDest - 1 );
            itemDest--;
        }
    }
}

void SortGroupByPage::AddQuickSelectSortingFields(const std::vector<FieldSorter> &allSorted, const std::vector<FieldSorter> &querySorted)
{
    for( std::vector<FieldSorter>::const_iterator it = allSorted.begin(); it < allSorted.end(); ++it )
    {
        wxVector<wxVariant> data;
        data.push_back( (*it).m_name );
        m_sortSource->InsertItem( (*it).m_originalPosition, data );
    }
    for( std::vector<FieldSorter>::const_iterator it = querySorted.begin(); it < querySorted.end(); ++it )
    {
        wxVector<wxVariant> data;
        data.push_back( (*it).m_name );
        data.push_back( (*it).m_isAscending );
        m_sortDest->InsertItem( (*it).m_originalPosition, data );
    }
}
