// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Mon Nov 28 23:55:36 2016
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

#ifndef WX_PRECOMP
    #include "wx/wx.h"
    #include "wx/stockitem.h"
#endif

#include <memory>
#include <map>
#include "wx/notebook.h"
#include "wx/bmpcbox.h"
#include "wx/docmdi.h"
#include "wx/filepicker.h"
#include "wx/fontenum.h"
#include "wx/listctrl.h"
#ifdef __WXGTK__
#include "gtk/gtk.h"
#include "wx/nativewin.h"
#endif
#ifdef __WXOSX__
#include "wx/fontpicker.h"
#endif
#ifdef __WXQT__
#include <QFontDialog>
#endif
#include "wxsf/ShapeCanvas.h"
#include "database.h"
#include "configuration.h"
//#include "objectproperties.h"
#include "propertieshandlerbase.h"
#include "guiobjectsproperties.h"
#include "field.h"
#include "fieldwindow.h"
#include "colorcombobox.h"
#include "propertypagebase.h"
#include "indexproperties.h"
#include "databaseoptionsgeneral.h"
#include "databaseoptioncolours.h"
#include "tablegeneral.h"
#include "fontpropertypagebase.h"
#include "tableprimarykey.h"
#include "fieldgeneral.h"
#include "designlabelgeneral.h"
#include "pointerproperty.h"
#include "fieldheader.h"
#include "fieldvalidation.h"
#include "bandgeneral.h"
#include "databasefielddisplay.h"
#include "painterobjects.h"
#include "libraryobjectpropertypage.h"
#include "librarypainteroptionsgeneral.h"
#include "librarypainteroptionsinclude.h"
#include "librarypainteroptionsmgmt.h"
#include "fieldstyles.h"
#include "properties.h"

#if _MSC_VER >= 1900 || !(defined __WXMSW__)
std::mutex Impl::my_mutex;
#endif

const wxEventTypeTag<wxCommandEvent> wxEVT_SET_TABLE_PROPERTY( wxEVT_USER_FIRST + 1 );
const wxEventTypeTag<wxCommandEvent> wxEVT_SET_FIELD_PROPERTY( wxEVT_USER_FIRST + 2 );

PropertiesDialog::PropertiesDialog(wxWindow* parent, wxWindowID id, const wxString& title, PropertiesHandler *handler, const DatabaseTable *table):
    wxDialog(parent, id, title)
{
    m_page1 = nullptr;
    m_page6 = nullptr;
    std::vector<std::wstring> errors;
    m_isApplied = false;
    m_handler = handler;
    // begin wxGlade: PropertiesDialog::PropertiesDialog
    long style = 0;
    if( handler->GetType() == TablePrpertiesType )
        style = wxNB_MULTILINE;
    m_properties = new wxNotebook( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, style );
    switch( handler->GetType() )
    {
        case DatabaseTablePropertiesType:
        case TablePrpertiesType:
        {
            TableProperties prop;
            if( handler->GetType() == DatabaseTablePropertiesType ) 
                prop = ( handler )->GetProperties().As<TableProperties>();
            else
                prop = table->GetTableProperties();
            wxFont data_font( prop.m_dataFontSize, wxFONTFAMILY_DEFAULT, prop.m_dataFontItalic ? wxFONTSTYLE_ITALIC : wxFONTSTYLE_NORMAL, prop.m_dataFontWeight ? wxFONTWEIGHT_BOLD : wxFONTWEIGHT_NORMAL, prop.m_dataFontUnderline, prop.m_dataFontName );
            if( prop.m_dataFontStrikethrough )
                data_font.SetStrikethrough( true );
            wxFont heading_font( prop.m_headingFontSize, wxFONTFAMILY_DEFAULT, prop.m_headingFontItalic ? wxFONTSTYLE_ITALIC : wxFONTSTYLE_NORMAL, prop.m_headingFontWeight ? wxFONTWEIGHT_BOLD : wxFONTWEIGHT_NORMAL, prop.m_headingFontUnderline, prop.m_headingFontName );
            if( prop.m_headingFontStrikethrough )
                heading_font.SetStrikethrough( true );
            wxFont label_font( prop.m_labelFontSize, wxFONTFAMILY_DEFAULT, prop.m_labelFontItalic ? wxFONTSTYLE_ITALIC : wxFONTSTYLE_NORMAL, prop.m_labelFontWeight ? wxFONTWEIGHT_BOLD : wxFONTWEIGHT_NORMAL, prop.m_labelFontUnderline, prop.m_labelFontName );
            if( prop.m_labelFontStrikethrough )
                label_font.SetStrikethrough( true );
            FontPropertyPage dataFont;
            dataFont.font = data_font;
            dataFont.text = wxColour( *wxBLACK );
            dataFont.back = wxColour( *wxWHITE );
            FontPropertyPage headingFont;
            headingFont.font = heading_font;
            headingFont.text = wxColour( *wxBLACK );
            headingFont.back = wxColour( *wxWHITE );
            FontPropertyPage labelFont;
            labelFont.font = label_font;
            labelFont.text = wxColour( *wxBLACK );
            labelFont.back = wxColour( *wxWHITE );
            m_page1 = new TableGeneralProperty( m_properties, table->GetTableName(), table->GetTableOwner(), prop.m_comment, true );
            m_properties->AddPage( m_page1, _( "General" ) );
            m_page2 = new CFontPropertyPage( m_properties, dataFont, false );
            m_page3 = new CFontPropertyPage( m_properties, headingFont, false );
            m_page4 = new CFontPropertyPage( m_properties, labelFont, false );
            m_page5 = new TablePrimaryKey( m_properties, table );
            m_properties->AddPage( m_page2, _( "Data Font" ) );
            m_properties->AddPage( m_page3, _( "Heading Font" ) );
            m_properties->AddPage( m_page4, _( "Label Font" ) );
            m_properties->AddPage( m_page5, _( "Primary Key" ) );
            if( handler->GetType() == TablePrpertiesType )
            {
                m_page19 = new TableIndex( m_properties, wxID_ANY, handler->GetDatabase(), L"", table->GetForeignKeyVector(), false );
                m_properties->InsertPage( 4, m_page19, _( "Foregn Key" ) );
                m_page20 = new TableIndex( m_properties, wxID_ANY, handler->GetDatabase(), L"", table->GetIndexNames(), true );
                m_properties->AddPage( m_page20, _( "Indexes" ) );
            }
        }
        break;
        case DatabaseFieldPropertiesType:
        {
            FieldProperties prop = ( handler )->GetProperties().As<FieldProperties>();
            auto type = ( handler )->GetFieldType();
            m_page6 = new FieldGeneral( m_properties, prop.m_comment );
            m_properties->AddPage( m_page6, _( "General" ) );
            m_page7 = new FieldHeader( m_properties, prop.m_heading );
            m_properties->AddPage( m_page7, _( "Headers" ) );
            m_page8 = new DatabaseFieldDisplay( m_properties, prop.m_display, handler->GetFieldType(), handler->GetDatabase() );
            m_properties->AddPage( m_page8, _( "Display" ) );
            m_page18 = new FieldValidation( m_properties, ( handler )->GetDatabase(), type );
            m_properties->AddPage( m_page18, _( "Validation" ) );
            m_page17 = new FieldStyles( m_properties );
            m_properties->AddPage( m_page17, _( "Edit Style" ) );
        }
        break;
        case DividerPropertiesType:
        {
/*            BandProperties prop = dynamic_cast<DividerPropertiesHandler *>( handler )->GetObjectProperties();
            m_page9 = new BandGeneralProperties( m_properties, prop );
            m_properties->AddPage( m_page9, _( "General" ) );
            m_page10 = new PointerPropertiesPanel( m_properties, prop.m_cursorFile, prop.m_cursor );
            m_properties->AddPage( m_page10, _( "Pointer" ) );*/
        }
        break;
        case DesignPropertiesType:
        {
/*            m_page9 = new DesignGeneral( parent, m_options );
            parent->AddPage( m_page1, _( "General" ) );
            m_page2 = new PointerPropertiesPanel( parent, m_options.cursorName, m_options.cursor );
            parent->AddPage( m_page2, _( "Pointer" ) );
            m_page3 = new PrintSpec( parent );
            parent->AddPage( m_page3, _( "Print Specification" ) );*/
        }
        break;
        case DatabasePropertiesType:
        case QueryPropertiesType:
        {
/*            auto prop = dynamic_cast<DatabaseOptionsHandler *>( handler )->GetObjectProperties();
            m_page11 = new DatabaseOptionGeneral( m_properties, prop.m_general );
            m_properties->AddPage( m_page11, _( "General" ) );
            m_page12 = new DatabaseptionsColours( m_properties, prop.m_colors, handler->GetType() == DatabasePropertiesType ? true : false );
            m_properties->AddPage( m_page12, _( "Colors" ) );*/
        }
        break;
        case LibraryPropertiesType:
        {
/*            auto prop = dynamic_cast<PropertiesHandler *>( handler )->GetLibraryProperties();
            m_page13 = new LibraryObjectPropertyPage( m_properties, prop );
            m_properties->AddPage( m_page13, _( "General" ) );*/
        }
        break;
        case LibraryPainterPropertiesType:
        {
/*            auto prop = dynamic_cast<PropertiesHandler *>( handler )->GetOptions();
            m_page14 = new LibraryPainterOptionsGeneralPage( m_properties, prop->m_general );
            m_properties->AddPage( m_page14, _( "General" ) );
            m_page15 = new LibraryPainterOptionsIncludePage( m_properties, prop->m_include );
            m_properties->AddPage( m_page15, _( "Include" ) );
            m_page16 = new LibraryPainterOptionsMgmtPage( m_properties, prop->m_management );
            m_properties->AddPage( m_page16, _( "Source Mgmt" ) );*/
        }
        break;
    }
//    handler->EditProperies( m_properties );
    set_properties();
    do_layout();
    // end wxGlade
    wxButton *apply = dynamic_cast<wxButton *>( FindWindowById( wxID_APPLY ) );
    wxButton *ok = dynamic_cast<wxButton *>( FindWindowById( wxID_OK ) );
    ok->SetDefault();
    apply->Enable( false );
    apply->Bind( wxEVT_BUTTON, &PropertiesDialog::OnApply, this );
    apply->Bind( wxEVT_UPDATE_UI, &PropertiesDialog::OnApplyUpdateUI, this );
    ok->Bind( wxEVT_BUTTON, &PropertiesDialog::OnOk, this );
}

void PropertiesDialog::set_properties()
{
    // begin wxGlade: PropertiesDialog::set_properties
    // end wxGlade
}

void PropertiesDialog::do_layout()
{
    // begin wxGlade: PropertiesDialog::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_2 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_3 = new wxBoxSizer( wxVERTICAL );
    wxSizer* buttonSizer = CreateButtonSizer( wxOK | wxCANCEL | wxAPPLY | wxHELP );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_3->Add( m_properties, 0, wxEXPAND, 0 );
    sizer_3->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_3->Add( buttonSizer, 0, wxEXPAND, 0 );
    sizer_2->Add( sizer_3, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_1->Add( sizer_2, 0, wxEXPAND, 0 );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    SetSizerAndFit( sizer_1 );
    Layout();
    // end wxGlade
}

void PropertiesDialog::OnApply(wxCommandEvent &WXUNUSED(event))
{
    if( ApplyProperties() )
    {
        dynamic_cast<wxButton *>( FindWindowById( wxID_APPLY ) )->Enable( false );
        if( !( m_page1 && m_page1->IsLogOnly() ) || ( !( m_page6 && m_page6->IsLogOnly() ) ) )
            FindWindowByName( "dbcanvas" )->Refresh();
        m_isApplied = true;
    }
}

void PropertiesDialog::OnOk(wxCommandEvent &WXUNUSED(event))
{
    if( !m_isApplied )
        ApplyProperties();
    wxYield();
    EndModal( wxID_OK );
}

bool PropertiesDialog::ApplyProperties()
{
    wxAny any;
    bool logOnly = false;
    switch( m_handler->GetType() )
    {
        case DatabaseFieldPropertiesType:
        {
            FieldProperties prop;
            logOnly = m_page6->IsLogOnly();
            prop.m_comment = m_page6->GetCommentCtrl()->GetValue();
            any = prop;
        }
        break;
        case DatabaseTablePropertiesType:
        {
            TableProperties prop;
            logOnly = m_page1->IsLogOnly();
            prop.m_comment = m_page1->GetCommentCtrl()->GetValue().ToStdWstring();
            prop.m_dataFontCharacterSet = m_page2->GetFont().font.GetEncoding();
            prop.m_dataFontSize = m_page2->GetFont().font.GetPointSize();
            prop.m_dataFontName = m_page2->GetFont().font.GetFaceName();
            prop.m_dataFontItalic = m_page2->GetFont().font.GetStyle() == wxFONTSTYLE_ITALIC;
            prop.m_dataFontStrikethrough = m_page2->GetFont().font.GetStrikethrough();
            prop.m_dataFontUnderline = m_page2->GetFont().font.GetUnderlined();
            prop.m_dataFontWeight = m_page2->GetFont().font.GetWeight();
            prop.m_headingFontCharacterSet = m_page3->GetFont().font.GetEncoding();
            prop.m_headingFontName = m_page3->GetFont().font.GetFaceName();
            prop.m_headingFontItalic = m_page3->GetFont().font.GetStyle() == wxFONTSTYLE_ITALIC;
            prop.m_headingFontName = m_page3->GetFont().font.GetFaceName();
            prop.m_headingFontItalic = m_page3->GetFont().font.GetStyle() == wxFONTSTYLE_ITALIC;
            prop.m_headingFontStrikethrough = m_page3->GetFont().font.GetStrikethrough();
            prop.m_headingFontUnderline = m_page3->GetFont().font.GetUnderlined();
            prop.m_headingFontWeight = m_page3->GetFont().font.GetWeight();
            prop.m_labelFontCharacterSer = m_page4->GetFont().font.GetEncoding();
            prop.m_labelFontName = m_page4->GetFont().font.GetFaceName();
            prop.m_labelFontName = m_page4->GetFont().font.GetFaceName();
            prop.m_labelFontItalic = m_page4->GetFont().font.GetStyle() == wxFONTSTYLE_ITALIC;
            prop.m_labelFontStrikethrough = m_page4->GetFont().font.GetStrikethrough();
            prop.m_labelFontUnderline = m_page4->GetFont().font.GetUnderlined();
            prop.m_labelFontWeight = m_page4->GetFont().font.GetWeight();
            any = prop;
        }
    }
    std::vector<std::wstring> errors;
    bool result = true;
    m_handler->ApplyProperties( any, logOnly, m_command );
/*    int res = m_handler->GetProperties( errors );
    if( !res )
    {
        for( size_t i = 0; i < m_properties->GetPageCount(); ++i )
        {
            PropertyPageBase *page = dynamic_cast<PropertyPageBase *>( m_properties->GetPage( i ) );
            page->SetModified( false );
        }
        m_isApplied = true;
    }
    else
    {
        wxMessageBox( "Error setting properties for the table" );
        for( std::vector<std::wstring>::iterator it = errors.begin(); it < errors.end(); ++it )
        {
            wxMessageBox( "Errors are " + (*it) );
        }
        result = false;
    }
/*    if( m_type == DatabaseTableProperties )
    {
        if( !m_isApplied && isModified )
        {
        }
    }*/
/*    if( m_type == DatabaseFieldProperties )
    {
        if( !m_isApplied && isModified )
        {
            static_cast<FieldProperties *>( m_object )->m_comment = m_page5->GetCommentCtrl()->GetValue().ToStdWstring();
            static_cast<FieldProperties *>( m_object )->m_label = m_page6->GetLabelCtrl()->GetValue().ToStdWstring();
            static_cast<FieldProperties *>( m_object )->m_heading = m_page6->GetHeadingCtrl()->GetValue().ToStdWstring();
            wxCommandEvent event( wxEVT_SET_FIELD_PROPERTY );
            event.SetInt( IsLogOnly() );
            event.SetExtraLong( m_type );
            event.SetClientData( &m_object );
            dynamic_cast<wxDocMDIChildFrame *>( GetParent() )->GetView()->ProcessEvent( event );
            if( event.GetString() == "Failed" )
                result = false;
        }
    }*/
    return result;
}

const std::wstring &PropertiesDialog::GetCommand()
{
    return m_command;
}

void PropertiesDialog::OnApplyUpdateUI (wxUpdateUIEvent &event)
{
    for( size_t i = 0; i < m_properties->GetPageCount(); ++i )
    {
        PropertyPageBase *page = dynamic_cast<PropertyPageBase *>( m_properties->GetPage( i ) );
        if( page->IsModified() )
            event.Enable( true );
    }
}

bool PropertiesDialog::IsLogOnly() const
{
    if( m_page1 )
        return m_page1->IsLogOnly();
    if( m_page6 )
        return m_page6->IsLogOnly();
    return false;
}
