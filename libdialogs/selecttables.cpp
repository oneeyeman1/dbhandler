// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Wed Jun 29 22:04:47 2016
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
#ifdef __GNUC__
#pragma implementation "dialogs.h"
#endif

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#include <string>
#include "database.h"
#include "selecttables.h"

SelectTables::SelectTables(wxWindow* parent, wxWindowID id, const wxString& title, Database *db, std::vector<std::wstring> &names, bool isTableView, const int type, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, style)
{
    m_db = db;
    m_names = names;
    sizer_1 = NULL;
    m_isTableView = isTableView;
    // begin wxGlade: SelectTables::SelectTables
    m_readOnly = NULL;
    m_panel = new wxPanel( this, wxID_ANY );
    m_tables = new wxListBox( m_panel, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0, NULL, isTableView ? wxLB_SINGLE : wxLB_MULTIPLE );
    m_showSystem = new wxCheckBox( m_panel, wxID_ANY, _( "&Show system tables" ) );
    if( m_isTableView )
        m_readOnly = new wxCheckBox( m_panel, wxID_ANY, _( "&Read-Only" ) );
    m_open = new wxButton( m_panel, wxID_ANY, _( "&Open" ) );
    m_new = new wxButton( m_panel, wxID_ANY, _( "&New..." ) );
    if( type == 1 )
        m_new->Enable( false );
    m_cancel = new wxButton( m_panel, wxID_CANCEL, _( "&Cancel" ) );
    m_help = new wxButton( m_panel, wxID_ANY, _( "&Help" ) );

    set_properties();
    do_layout();
    // end wxGlade
    m_open->Bind( wxEVT_BUTTON, &SelectTables::OnOpenTables, this );
    m_showSystem->Bind( wxEVT_CHECKBOX, &SelectTables::OnShowSystemTables, this );
}

void SelectTables::GetSelectedTableNames(std::vector<wxString> &tableNames, std::map<wxString, std::vector<wxString> >&schemaNames)
{
    wxArrayInt selections;
    m_tables->GetSelections( selections );
    for( auto i = 0; i < selections.GetCount(); i++ )
    {
        wxString schema = dynamic_cast<wxStringClientData *>( m_tables->GetClientObject( i ) )->GetData();
        tableNames.push_back( m_tables->GetString( selections.Item( i ) ) );
        schemaNames[schema].push_back( m_tables->GetString( selections.Item( i ) ) );
    }
}

void SelectTables::set_properties()
{
    // begin wxGlade: SelectTables::set_properties
    SetTitle( _( "Select Tables" ) );
    m_open->Enable( false );
    m_open->SetDefault();
    FillTableList( false );
    // end wxGlade
}

void SelectTables::do_layout()
{
    // begin wxGlade: SelectTables::do_layout
    sizer_1 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_4 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_5 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_6 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_8 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_7 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_9 = new wxBoxSizer( wxHORIZONTAL );
    sizer_4->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_5->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_7->Add( m_tables, 0, wxEXPAND, 0 );
    sizer_7->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_9->Add( m_showSystem, 0, wxEXPAND, 0 );
    if( m_isTableView )
    {
        sizer_9->Add( 40, 40, 0, wxEXPAND, 0 );
        sizer_9->Add( m_readOnly, 0, wxEXPAND, 0 );
    }
    sizer_7->Add( sizer_9, 0, wxEXPAND, 0 );
    sizer_6->Add( sizer_7, 0, 0, 0 );
    sizer_6->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_open, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_new, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_cancel, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_help, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 30, 30, 0, wxEXPAND, 0 );
    sizer_6->Add( sizer_8, 0, 0, 0 );
    sizer_5->Add( sizer_6, 0, 0, 0 );
    sizer_5->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_4->Add( sizer_5, 0, 0, 0 );
    sizer_4->Add( 5, 5, 0, wxEXPAND, 0 );
    m_panel->SetSizer( sizer_4 );
    sizer_1->Add( m_panel, 0, 0, 0 );
    SetSizer( sizer_1 );
    sizer_1->Fit( this );
    Layout();
    // end wxGlade
}

BEGIN_EVENT_TABLE(SelectTables, wxDialog)
    // begin wxGlade: SelectTables::event_table
    EVT_LISTBOX(wxID_ANY, SelectTables::OnSelectingLBItem)
    // end wxGlade
END_EVENT_TABLE();


void SelectTables::OnSelectingLBItem(wxCommandEvent &WXUNUSED(event))
{
    m_open->Enable( true );
}

void SelectTables::OnOpenTables(wxCommandEvent &event)
{
    EndModal( dynamic_cast<wxButton *>( event.GetEventObject() )->GetId() );
}

// wxGlade: add SelectTables event handlers

void SelectTables::FillTableList(bool sysTableIncluded)
{
    m_tables->Clear();
    bool insert = false;
    std::wstring type = m_db->GetTableVector().m_type;
    std::wstring subType = m_db->GetTableVector().m_subtype;
    std::lock_guard<std::mutex> locker( m_db->GetTableVector().my_mutex );
    std::map<std::wstring,std::vector<TableDefinition> > tables = m_db->GetTableVector().m_tableDefinitions;
    std::wstring dbName = m_db->GetTableVector().m_dbName;
    for( std::map<std::wstring,std::vector<TableDefinition> >::iterator it = tables.begin(); it != tables.end(); it++ )
    {
        if( (*it).first == dbName )
        {
            for( std::vector<TableDefinition>::iterator it1 = (*it).second.begin(); it1 < (*it).second.end(); it1++ )
            {
                std::wstring tableName = (*it1).tableName;
                std::wstring schemaName = (*it1).schemaName;
                if( std::find( m_names.begin(), m_names.end(), tableName ) == m_names.end() )
                {
                    if( type == L"SQLite" )
                    {
                        if( schemaName == L"" )
                            schemaName = L"master";
                        if( !sysTableIncluded && ( ( tableName.substr( 0, 6 ) != L"sqlite" ) && ( tableName.substr( 0, 3 ) != L"sys" ) ) )
                            insert = true;
                        else if( sysTableIncluded )
                            insert = true;
                    }
                    else if( ( ( type == L"ODBC" && subType == L"Microsoft SQL Server" ) || type == L"Microsoft SQL Server" ) ||
                               ( type == L"ODBC" && subType == L"Sybase SQL Anywhere" ) || type == L"Sybase SQL Anywhere" )
                    {
                        if( !sysTableIncluded && ( tableName.substr( 0, 5 ) == L"abcat" || schemaName.find( L"sys" ) != std::wstring::npos || schemaName.find( L"INFORMATION_SCHEMA" ) != std::wstring::npos || schemaName.find( L"SYS" ) != std::wstring::npos ) )
                            continue;
                        else
                        {
                            insert = true;
                        }
                    }
                    else if( ( type == L"ODBC" && subType == L"MySQL" ) || type == L"MySQL" )
                    {
                        if( !sysTableIncluded && ( tableName.substr( 0, 5 ) == L"abcat" || schemaName == L"information_schema" ) )
                            continue;
                        else
                            insert = true;
                    }
                    else if( ( type == L"ODBC" && subType == L"PostgreSQL" ) || type == L"PostgreSQL" )
                    {
                        if( !sysTableIncluded && ( tableName.substr( 0, 5 ) == L"abcat" || ( schemaName == L"information_schema" || schemaName == L"pg_catalog" ) ) )
                            continue;
                        else
                            insert = true;
                    }
                    if( insert )
                        m_tables->Append( tableName, new wxStringClientData( schemaName ) );
                    insert = false;
                }
            }
        }
    }
}

void SelectTables::OnShowSystemTables(wxCommandEvent &WXUNUSED(event))
{
    if( m_showSystem->IsChecked() )
        FillTableList( true );
    else
        FillTableList( false );
}
