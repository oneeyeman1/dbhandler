// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Wed Jun 29 22:04:47 2016
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
#ifdef __GNUC__
#pragma implementation "dialogs.h"
#endif

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#include <string>
#include "database.h"
#include "dialogs.h"
#include "selecttables.h"

SelectTables::SelectTables(wxWindow* parent, wxWindowID id, const wxString& title, Database *db, std::vector<std::wstring> &names, bool isTableView, const int type, bool isNewView):
    wxDialog(parent, id, title)
{
    m_isNewView = isNewView;
    m_db = db;
    m_names = names;
    sizer_1 = NULL;
    m_isTableView = isTableView;
    // begin wxGlade: SelectTables::SelectTables
    m_readOnly = NULL;
    m_panel = new wxPanel( this, wxID_ANY );
    m_tables = new wxListBox( m_panel, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0, NULL, isTableView ? wxLB_SINGLE : wxLB_MULTIPLE );
    if( isTableView )
        m_single = true;
    else
        m_single = false;
    m_showSystem = new wxCheckBox( m_panel, wxID_ANY, _( "&Show system tables" ) );
    if( m_isTableView )
        m_readOnly = new wxCheckBox( m_panel, wxID_ANY, _( "&Read-Only" ) );
    m_open = new wxButton( m_panel, wxID_OK, _( "&Open" ) );
    m_new = new wxButton( m_panel, wxID_ANY, _( "&New..." ) );
    if( type == 1 )
        m_new->Enable( false );
    if( isTableView )
        m_new->Enable( true );
    m_cancel = new wxButton( m_panel, wxID_CANCEL, _( "&Cancel" ) );
    m_help = new wxButton( m_panel, wxID_ANY, _( "&Help" ) );

    set_properties();
    do_layout();
    // end wxGlade
    m_open->Bind( wxEVT_BUTTON, &SelectTables::OnOpenTables, this );
    m_open->Bind( wxEVT_UPDATE_UI, &SelectTables::OnOpenUpdateUI, this );
    m_cancel->Bind( wxEVT_BUTTON, &SelectTables::OnCancel, this );
    m_showSystem->Bind( wxEVT_CHECKBOX, &SelectTables::OnShowSystemTables, this );
    m_tables->Bind( wxEVT_LISTBOX_DCLICK, &SelectTables::OnListDClick, this );
}

void SelectTables::GetSelectedTableNames(std::map<wxString, std::vector<TableDefinition> > &tableNames)
{
    wxArrayInt selections;
    m_tables->GetSelections( selections );
    for( size_t i = 0; i < selections.GetCount(); i++ )
    {
        ClientData *data = (ClientData *) m_tables->GetClientData( i );
        tableNames[data->catalog].push_back( TableDefinition( data->catalog, data->schema, data->table ) );
    }
    for( size_t i = 0; i < m_tables->GetCount(); ++i )
    {
        delete (ClientData *) m_tables->GetClientData( i );
    }
}

void SelectTables::set_properties()
{
    // begin wxGlade: SelectTables::set_properties
    SetTitle( _( "Select Tables" ) );
    m_open->Enable( false );
    m_open->SetDefault();
    FillTableList( false );
    // end wxGlade
}

void SelectTables::do_layout()
{
    // begin wxGlade: SelectTables::do_layout
    sizer_1 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_4 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_5 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_6 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_8 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_7 = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer* sizer_9 = new wxBoxSizer( wxHORIZONTAL );
    sizer_4->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_5->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_7->Add( m_tables, 0, wxEXPAND, 0 );
    sizer_7->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_9->Add( m_showSystem, 0, wxEXPAND, 0 );
    if( m_isTableView )
    {
        sizer_9->Add( 40, 40, 0, wxEXPAND, 0 );
        sizer_9->Add( m_readOnly, 0, wxEXPAND, 0 );
    }
    sizer_7->Add( sizer_9, 0, wxEXPAND, 0 );
    sizer_6->Add( sizer_7, 0, 0, 0 );
    sizer_6->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_open, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_new, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_cancel, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_8->Add( m_help, 0, wxALIGN_CENTER_HORIZONTAL, 0 );
    sizer_8->Add( 30, 30, 0, wxEXPAND, 0 );
    sizer_6->Add( sizer_8, 0, 0, 0 );
    sizer_5->Add( sizer_6, 0, 0, 0 );
    sizer_5->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_4->Add( sizer_5, 0, 0, 0 );
    sizer_4->Add( 5, 5, 0, wxEXPAND, 0 );
    m_panel->SetSizer( sizer_4 );
    sizer_1->Add( m_panel, 0, 0, 0 );
    SetSizer( sizer_1 );
    sizer_1->Fit( this );
    Layout();
    // end wxGlade
}

void SelectTables::OnOpenUpdateUI(wxUpdateUIEvent &event)
{
    if(  m_single && m_tables->GetSelection() ) 
        event.Enable( true );
    else if( !m_single )
    {
        wxArrayInt sel;
        m_tables->GetSelections( sel );
        if( sel.size() > 0 )
            event.Enable( true );
        else
            event.Enable( false );
    }
    else
        event.Enable( false );
}

void SelectTables::OnOpenTables(wxCommandEvent &event)
{
    EndModal( dynamic_cast<wxButton *>( event.GetEventObject() )->GetId() );
}

// wxGlade: add SelectTables event handlers

void SelectTables::FillTableList(bool sysTableIncluded)
{
    m_tables->Clear();
    bool insert = false;
    std::wstring type = m_db->GetTableVector().m_type;
    std::wstring subType = m_db->GetTableVector().m_subtype;
    std::lock_guard<std::mutex> locker( m_db->GetTableVector().my_mutex );
    std::map<std::wstring,std::vector<TableDefinition> > tables = m_db->GetTableVector().m_tableDefinitions;
    auto size = tables.size();
    std::wstring dbName = m_db->GetTableVector().m_dbName;
    for( std::map<std::wstring,std::vector<TableDefinition> >::iterator it = tables.begin(); it != tables.end(); it++ )
    {
        for( std::vector<TableDefinition>::iterator it1 = (*it).second.begin(); it1 < (*it).second.end(); it1++ )
        {
            std::wstring tableName = (*it1).tableName;
            std::wstring schemaName = (*it1).schemaName;
            std::wstring catalogName = (*it1).catalogName;
            if( ( std::find( m_names.begin(), m_names.end(), tableName ) == m_names.end() && !m_isNewView ) || m_isNewView )
            {
                if( type == L"SQLite" )
                {
                    if( schemaName == L"" )
                        schemaName = L"main";
                    if( !sysTableIncluded && ( ( tableName.substr( 0, 6 ) != L"sqlite" ) && ( tableName.substr( 0, 3 ) != L"sys" ) ) )
                        insert = true;
                    else if( sysTableIncluded )
                        insert = true;

                    tableName = schemaName + L"." + tableName;
                }
                else if( ( ( type == L"ODBC" && subType == L"Microsoft SQL Server" ) || type == L"Microsoft SQL Server" ) ||
                           ( type == L"ODBC" && subType == L"Sybase SQL Anywhere" ) || type == L"Sybase SQL Anywhere" )
                {
                    if( !sysTableIncluded && ( tableName.substr( 0, 5 ) == L"abcat" || schemaName.find( L"sys" ) != std::wstring::npos || schemaName.find( L"INFORMATION_SCHEMA" ) != std::wstring::npos || schemaName.find( L"SYS" ) != std::wstring::npos ) )
                        continue;
                    else
                    {
                        insert = true;
                    }
//                    if( size > 1 )
                    tableName = catalogName + L"." + schemaName + L"." + tableName;
                }
                else if( ( type == L"ODBC" && subType == L"MySQL" ) || type == L"mySQL" )
                {
                    if( !sysTableIncluded && ( schemaName != dbName || tableName.substr( 0, 5 ) == L"abcat" ) )
                        continue;
                    else
                        insert = true;
                }
                else if( ( type == L"ODBC" && subType == L"PostgreSQL" ) || type == L"PostgreSQL" )
                {
                    if( !sysTableIncluded && ( tableName.substr( 0, 5 ) == L"abcat" || ( schemaName == L"information_schema" || schemaName == L"pg_catalog" ) ) )
                        continue;
                    else
                        insert = true;
                }
                if( insert )
                {
                    m_tables->Append( tableName, new ClientData( catalogName, schemaName, (*it1).tableName ) );
                }
                insert = false;
            }
        }
    }
}

void SelectTables::OnShowSystemTables(wxCommandEvent &WXUNUSED(event))
{
    for( size_t i = 0; i < m_tables->GetCount(); ++i )
        delete (ClientData *) m_tables->GetClientData( i );
    if( m_showSystem->IsChecked() )
        FillTableList( true );
    else
        FillTableList( false );
}

void SelectTables::OnCancel(wxCommandEvent &WXUNUSED(event))
{
    for( size_t i = 0; i < m_tables->GetCount(); ++i )
        delete (ClientData *) m_tables->GetClientData( i );
    EndModal( wxID_CANCEL );
}

void SelectTables::OnListDClick(wxCommandEvent &WXUNUSED(event))
{
    if( m_isTableView )
        EndModal( wxID_OK );
}
