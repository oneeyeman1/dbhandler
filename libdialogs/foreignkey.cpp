// -*- C++ -*-
//
// generated by wxGlade 0.7.2 (standalone edition) on Wed Jan 25 23:33:43 2017
//
// Example for compiling a single file project under Linux using g++:
//  g++ MyApp.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp
//
// Example for compiling a multi file project under Linux using g++:
//  g++ main.cpp $(wx-config --libs) $(wx-config --cxxflags) -o MyApp Dialog1.cpp Frame1.cpp
//
// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include "wx/gbsizer.h"
#include "database.h"
#include "wxsf/ShapeCanvas.h"
#include "field.h"
#include "fieldwindow.h"
#include "foreignkey.h"

// begin wxGlade: ::extracode
// end wxGlade



ForeignKeyDialog::ForeignKeyDialog(wxWindow* parent, wxWindowID id, const wxString& title, DatabaseTable *table, Database *db, wxString &keyName, std::vector<std::wstring> &foreignKeyFields, wxString &refTableName, bool isView, int matchOptions, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, style)
{
    m_match = matchOptions;
    m_matching = NULL;
    m_db = db;
    m_table = table;
    m_isLogOnly = false;
    m_isView = isView;
    m_refTableName = refTableName;
    m_edited = false;
    // begin wxGlade: ForeignKeyDialog::ForeignKeyDialog
    m_label1 = new wxStaticText( this, wxID_ANY, _( "Foreign Key Name:" ) );
    m_foreignKeyName = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_label3 = new wxStaticText( this, wxID_ANY, _( "Primary Key Table:" ) );
    m_primaryKeyTable = new wxComboBox( this, wxID_ANY, wxT( "" ), wxDefaultPosition, wxDefaultSize, 0, NULL, wxCB_DROPDOWN | wxCB_READONLY );
    m_label2 = new wxStaticText( this, wxID_ANY, _( "Foreign Key Columns:" ) );
    m_foreignKeyColumns = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_label4 = new wxStaticText( this, wxID_ANY, _( "Primary Key Columns:" ) );
    m_primaryKeyColumns = new wxTextCtrl( this, wxID_ANY, wxEmptyString );
    m_OK = new wxButton( this, wxID_OK, _( "OK" ) );
    m_cancel = new wxButton( this, wxID_CANCEL, _( "Cancel" ) );
    m_help = new wxButton( this, wxID_HELP, _( "&Help" ) );
    m_logOnly = new wxButton( this, wxID_ANY, _( "Log Only" ) );
    m_label6 = new wxStaticText( this, wxID_ANY, _( "Select Columns:" ) );
    list_ctrl_1 = new wxListCtrl( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT );
    const wxString m_onDelete_choices[] = {
        _( "Perform No Action (NO ACTION)" ),
        _( "Disallow if Dependent Row Exist (RESTRICT)" ),
        _( "Delete any Dependent Row (CASCADE)" ),
        _( "Set Dependent Columns to NULL (SET NULL)" ),
        _( "Set to Default (SET DEFAULT)" ),
    };
    const wxString m_onUpdate_choices[] = {
        _( "Perform No Action (NO ACTION)" ),
        _( "Disallow if Dependent Row Exist (RESTRICT)" ),
        _( "Update any Dependent Row (CASCADE)" ),
        _( "Set Dependent Columns to NULL (SET NULL)" ),
        _( "Set to Default (SET DEFAULT)" ),
    };
    m_onDelete = new wxRadioBox( this, wxID_ANY, _( "On Delete of Primary Table Row" ), wxDefaultPosition, wxDefaultSize, 5, m_onDelete_choices, 1, wxRA_SPECIFY_COLS );
    m_onUpdate = new wxRadioBox( this, wxID_ANY, _( "On Update of Primary Table Row" ), wxDefaultPosition, wxDefaultSize, 5, m_onUpdate_choices, 1, wxRA_SPECIFY_COLS );
    if( m_db->GetTableVector().m_type == L"PostgreSQL" || ( m_db->GetTableVector().m_type == L"ODBC" && m_db->GetTableVector().m_subtype == L"PostgreSQL" ) )
    {
        const wxString m_matching_choices[] = {
            _( "MATCH FULL" ),
            _( "MATCH PARTIAL" ),
            _( "MATCH SIMPLE" ),
        };
        m_matching = new wxRadioBox( this, wxID_ANY, _( "Matching Options" ), wxDefaultPosition, wxDefaultSize, 3, m_matching_choices, 3, wxRA_SPECIFY_COLS );
    }
    m_OK->Bind( wxEVT_BUTTON, &ForeignKeyDialog::OnApplyCommand, this );
    m_logOnly->Bind( wxEVT_BUTTON, &ForeignKeyDialog::OnApplyCommand, this );
    m_primaryKeyTable->Bind( wxEVT_COMBOBOX, &ForeignKeyDialog::OnPrimaryKeyTableSelection, this );
    m_onDelete->Bind( wxEVT_RADIOBOX, &ForeignKeyDialog::OnDeleteChanges, this );
    m_onUpdate->Bind( wxEVT_RADIOBOX, &ForeignKeyDialog::OnUpdateChanges, this );
    list_ctrl_1->Bind( wxEVT_LEFT_DOWN, &ForeignKeyDialog::OnSelectDeselectField, this );
    set_properties();
    do_layout();
    // end wxGlade
    wxPoint pt1 = m_foreignKeyColumns->GetPosition();
    int width1 = m_foreignKeyColumns->GetSize().GetWidth();
    m_foreignKeyColumns->Hide();
    m_foreignKeyColumnsFields = new FieldWindow( this, pt1, width1 );
    wxPoint pt2 = m_primaryKeyColumns->GetPosition();
    int width2 = m_primaryKeyColumns->GetSize().GetWidth();
    m_primaryKeyColumns->Hide();
    m_primaryKeyColumnsFields = new FieldWindow( this, pt2, width2 );
    if( m_isView )
    {
        m_foreignKeyName->SetValue( keyName );
        m_primaryKeyTable->SetValue( m_refTableName );
        DoChangePrimaryKeyTableName();
        for( std::vector<std::wstring>::iterator it = foreignKeyFields.begin(); it < foreignKeyFields.end(); it++ )
        {
            list_ctrl_1->SetItemState( list_ctrl_1->FindItem( -1, (*it) ), wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED );
        }
    }
}

ForeignKeyDialog::~ForeignKeyDialog()
{
    delete m_foreignKeyColumnsFields;
    m_foreignKeyColumnsFields = NULL;
    delete m_primaryKeyColumnsFields;
    m_primaryKeyColumnsFields = NULL;
}

void ForeignKeyDialog::set_properties()
{
    // begin wxGlade: ForeignKeyDialog::set_properties
    SetTitle( _( "Foreign Key Definition - " ) + m_table->GetTableName() );
    if( ( m_db->GetTableVector().m_type == L"ODBC" && m_db->GetTableVector().m_subtype == L"Microsoft SQL Server" ) || m_db->GetTableVector().m_type == L"Microsoft SQL Server" )
    {
        m_onUpdate->Enable( 1, false );
        m_onDelete->Enable( 1, false );
    }
    if( ( m_db->GetTableVector().m_type == L"ODBC" && m_db->GetTableVector().m_subtype == L"PostgreSQL" ) || m_db->GetTableVector().m_type == L"PostgreSQL" )
    {
        m_matching->SetSelection( m_match );
    }
    m_OK->SetDefault();
    m_onDelete->SetSelection( 0 );
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = m_db->GetTableVector().m_tables.begin(); it != m_db->GetTableVector().m_tables.end(); it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (*it).second.begin(); it1 < (*it).second.end(); it1++ )
        {
            if( (*it1)->GetTableName() != m_table->GetTableName() && (*it1)->GetSchemaName() == m_table->GetSchemaName() )
                m_primaryKeyTable->AppendString( (*it1)->GetTableName() );
        }
    }
    list_ctrl_1->AppendColumn( m_table->GetTableName() );
    int row = 0;
    for( std::vector<TableField *>::const_iterator it = m_table->GetFields().begin(); it < m_table->GetFields().end(); it++ )
    {
        list_ctrl_1->InsertItem( row++, (*it)->GetFieldName() );
    }
    // end wxGlade
    if( m_db->GetTableVector().GetDatabaseType() == L"SQLite" )
        m_foreignKeyName->Disable();
}


void ForeignKeyDialog::do_layout()
{
    // begin wxGlade: ForeignKeyDialog::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer( wxHORIZONTAL );
    wxBoxSizer* sizer_2 = new wxBoxSizer( wxVERTICAL );
    wxGridBagSizer* grid_sizer_1 = new wxGridBagSizer( 5, 5 );
    wxBoxSizer *buttonSizer = new wxBoxSizer( wxVERTICAL );
    wxBoxSizer *optionsSizer = new wxBoxSizer( wxVERTICAL );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_OK, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_cancel, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_help, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    buttonSizer->Add( m_logOnly, 0, wxEXPAND, 0 );
    buttonSizer->Add( 5, 5, 0, wxEXPAND, 0 );
    optionsSizer->Add( m_onDelete, 0, 0, 0 );
    optionsSizer->Add( 5, 5, 0, 0, 0 );
    optionsSizer->Add( m_onUpdate, 0, 0, 0 );
    if( m_db->GetTableVector().m_type == L"PostgreSQL" || ( m_db->GetTableVector().m_type == L"ODBC" && m_db->GetTableVector().m_subtype == L"PostgreSQL" ) )
    {
        optionsSizer->Add( 5, 5, 0, wxEXPAND, 0 );
        optionsSizer->Add( m_matching, 0, wxEXPAND, 0 );
    }
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    grid_sizer_1->Add( m_label1, wxGBPosition( 0, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label3, wxGBPosition( 0, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( buttonSizer, wxGBPosition( 0, 2 ), wxGBSpan( 4, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_foreignKeyName, wxGBPosition( 1, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_primaryKeyTable, wxGBPosition( 1, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label2, wxGBPosition( 2, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label4, wxGBPosition( 2, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_foreignKeyColumns, wxGBPosition( 3, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_primaryKeyColumns, wxGBPosition( 3, 1 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( m_label6, wxGBPosition( 4, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( list_ctrl_1, wxGBPosition( 5, 0 ), wxGBSpan( 1, 1 ), wxEXPAND );
    grid_sizer_1->Add( optionsSizer, wxGBPosition( 5, 1 ), wxGBSpan( 2, 2 ),/*, wxEXPAND*/0 );
    grid_sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_2->Add( grid_sizer_1, 0, wxEXPAND, 0 );
    sizer_2->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_1->Add( sizer_2, 0, wxEXPAND, 0 );
    sizer_1->Add( 5, 5, 0, wxEXPAND, 0 );
    SetSizer( sizer_1 );
    sizer_1->Fit( this );
    Layout();
    // end wxGlade
}

bool ForeignKeyDialog::Verify()
{
    bool verified = true;
    if( m_primaryKeyTable->GetValue().IsEmpty() )
    {
        wxMessageBox( _( "Primary key table name is required" ) );
        verified = false;
    }
    else if( m_foreignKey.empty() )
    {
        wxMessageBox( _( "Please select columns for Foreign key" ) );
        verified = false;
    }
    else if( m_foreignKey.size() != m_primaryKey.size() )
    {
        wxMessageBox( _( "Number of columns in Foreign Key must match number of columns in Primary Key" ) );
        verified = false;
    }
    return verified;
}

void ForeignKeyDialog::OnApplyCommand(wxCommandEvent &event)
{
    FK_ONUPDATE updateProp = NO_ACTION_UPDATE;
    FK_ONDELETE deleteProp = NO_ACTION_DELETE;
    if( Verify() )
    {
        if( event.GetEventObject() == m_logOnly )
            m_isLogOnly = true;
        m_delete = m_onDelete->GetSelection();
        m_update = m_onUpdate->GetSelection();
        if( m_matching )
            m_match = m_matching->GetSelection();
		else
            m_match = -1;
        switch( m_delete )
        {
            case 0:
                deleteProp = NO_ACTION_DELETE;
                break;
            case 1:
                deleteProp = RESTRICT_DELETE;
                break;
            case 2:
                deleteProp = CASCADE_DELETE;
                break;
            case 3:
                deleteProp = SET_NULL_DELETE;
                break;
            case 4:
                deleteProp = SET_DEFAULT_DELETE;
                break;
        }
        switch( m_update )
        {
            case 0:
                updateProp = NO_ACTION_UPDATE;
                break;
            case 1:
                updateProp = RESTRICT_UPDATE;
                break;
            case 2:
                updateProp = CASCADE_UPDATE;
                break;
            case 3:
                updateProp = SET_NULL_UPDATE;
                break;
            case 4:
                updateProp = SET_DEFAULT_UPDATE;
                break;
        }
        for( size_t i = 0; i < m_foreignKey.size(); i++ )
            m_fkfield.push_back( new FKField( i, m_foreignKeyName->GetValue().ToStdWstring(), m_table->GetSchemaName(), m_table->GetTableName(), m_foreignKey.at( i ), m_table->GetSchemaName(), m_primaryKeyTable->GetValue().ToStdWstring(), m_primaryKey.at( i ), GetForeignKeyFields(), GetPrimaryKeyFields(), updateProp, deleteProp ) );
        EndModal( event.GetId() );
    }
}

void ForeignKeyDialog::OnPrimaryKeyTableSelection(wxCommandEvent &WXUNUSED(event))
{
    DoChangePrimaryKeyTableName();
    m_edited = true;
/*    bool found = false;
    m_primaryKeyColumnsFields->Clear();
    m_primaryKey.clear();
    std::map<std::wstring, std::vector<DatabaseTable *> > tableVec = m_db->GetTableVector().m_tables;
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = tableVec.begin(); it != tableVec.end() && !found; it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (it)->second.begin(); it1 < (*it).second.end() && !found; it1++ )
        {
            if( (*it1)->GetTableName() == m_primaryKeyTable->GetValue() )
            {
                m_pkTable = (*it1);
                found = true;
            }
        }
    }
    for( std::vector<Field *>::const_iterator it = m_pkTable->GetFields().begin(); it < m_pkTable->GetFields().end(); it++ )
    {
        if( (*it)->IsPrimaryKey() )
        {
            m_primaryKeyColumnsFields->AddField( (*it)->GetFieldName() );
            m_primaryKey.push_back( (*it)->GetFieldName() );
        }
    }
    m_refTableName = m_primaryKeyTable->GetValue();*/
}

bool ForeignKeyDialog::IsLogOnlyI()
{
    return m_isLogOnly;
}

wxTextCtrl *ForeignKeyDialog::GetKeyNameCtrl() const
{
    return m_foreignKeyName;
}

std::vector<FKField *> &ForeignKeyDialog::GetForeignKeyVector()
{
    return m_fkfield;
}

const std::vector<std::wstring> &ForeignKeyDialog::GetForeignKeyFields() const
{
    return m_foreignKey;
}

const std::vector<std::wstring> &ForeignKeyDialog::GetPrimaryKeyFields() const
{
    return m_primaryKey;
}

const std::wstring &ForeignKeyDialog::GetReferencedTable() const
{
    return m_refTableName;
}

int ForeignKeyDialog::GetDeleteParam() const
{
    return m_delete;
}

int ForeignKeyDialog::GetUpdateParam() const
{
    return m_update;
}

void ForeignKeyDialog::DoChangePrimaryKeyTableName()
{
    bool found = false;
    m_primaryKeyColumnsFields->Clear();
    m_primaryKey.clear();
    std::map<std::wstring, std::vector<DatabaseTable *> > tableVec = m_db->GetTableVector().m_tables;
    for( std::map<std::wstring, std::vector<DatabaseTable *> >::iterator it = tableVec.begin(); it != tableVec.end() && !found; it++ )
    {
        for( std::vector<DatabaseTable *>::iterator it1 = (it)->second.begin(); it1 < (*it).second.end() && !found; it1++ )
        {
            if( (*it1)->GetTableName() == m_primaryKeyTable->GetValue() )
            {
                m_pkTable = (*it1);
                found = true;
            }
        }
    }
    for( std::vector<TableField *>::const_iterator it = m_pkTable->GetFields().begin(); it < m_pkTable->GetFields().end(); it++ )
    {
        if( (*it)->IsPrimaryKey() )
        {
            m_primaryKeyColumnsFields->AddField( (*it)->GetFieldName() );
            m_primaryKey.push_back( (*it)->GetFieldName() );
        }
    }
    m_refTableName = m_primaryKeyTable->GetValue();
}

void ForeignKeyDialog::OnDeleteChanges(wxCommandEvent &WXUNUSED(event))
{
    m_edited = true;
}

void ForeignKeyDialog::OnUpdateChanges(wxCommandEvent &WXUNUSED(event))
{
    m_edited = true;
}

bool ForeignKeyDialog::IsForeignKeyEdited() const
{
    return m_edited;
}

int ForeignKeyDialog::GetMatchingOptions() const
{
    return m_match;
}

void ForeignKeyDialog::OnSelectDeselectField(wxMouseEvent &event)
{
    int flags;
    auto item = list_ctrl_1->HitTest( event.GetPosition(), flags );
    if( item != wxNOT_FOUND )
    {
        auto label = list_ctrl_1->GetItemText( item );
        auto state = list_ctrl_1->GetItemState( item, wxLIST_STATE_SELECTED );
        if( state & wxLIST_STATE_SELECTED )
        {
            m_foreignKey.erase( std::remove_if( m_foreignKey.begin(), m_foreignKey.end(),
                                           [&label](const std::wstring &e1) { return e1.find( label ) != e1.npos; } ), m_foreignKey.end() );
            m_foreignKeyColumnsFields->RemoveField( label );
            list_ctrl_1->SetItemState( item, 0, wxLIST_STATE_SELECTED );
            list_ctrl_1->SetItemState( item, 0, wxLIST_STATE_FOCUSED );
        }
        else
        {
            m_foreignKeyColumnsFields->AddField( label );
            m_foreignKey.push_back( label.ToStdWstring() );
            list_ctrl_1->SetItemState( item, wxLIST_STATE_FOCUSED, wxLIST_STATE_FOCUSED );
            event.Skip();
        }
    }
}

void ForeignKeyDialog::OnOkUpdateUI(wxUpdateUIEvent &event)
{
    if( m_db->GetTableVector().GetDatabaseType() != L"SQLite" )
    {
        if( m_foreignKeyName->GetValue() == wxEmptyString )
        {
            event.Enable( false );
        }
        else
        {
            event.Enable( true );
        }
    }
}
