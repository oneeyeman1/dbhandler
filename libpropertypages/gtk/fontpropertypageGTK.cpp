// -*- C++ -*- generated by wxGlade 0.5 on Wed Feb 06 22:39:49 2008
/***************************************************************************
 *   Copyright (C) 2005 by Igor Korot                                      *
 *   igor@IgorsGentoo                                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#ifdef __WXGTK__
#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#include <gtk/gtk.h>
#include <glib-object.h>
#include "wx/font.h"
#include "wx/fontutil.h"
#include "wx/button.h"
#include "wx/nativewin.h"
#include "wx/bmpcbox.h"
#include "colorcombobox.h"
#include "propertypagebase.h"
#include "fontpropertypagebase.h"

extern "C"
{
static void font_name_change(GtkFontChooser *view, CFontPropertyPage *page)
{
    page->SetModified( true );
    GtkTreeIter iter;
    GValue value = G_VALUE_INIT;
    GList *selRows = NULL;
    gchar *pangoFont = gtk_font_chooser_get_font( view );
    wxFont font/*( pangoFont )*/;
//    font.font.SetNativeFontInfo( pangoFont );
//    page->SetFont( font.font );
/*    GtkTreeSelection *sel = gtk_tree_view_get_selection( view );
    GtkTreeModel *model = gtk_tree_view_get_model( view );
    selRows = gtk_tree_selection_get_selected_rows( sel, &model );
    if( selRows )
    {
        gchar *string1 = gtk_tree_path_to_string( (GtkTreePath *) selRows[0].data );
        g_free( string1 );
        if( gtk_tree_model_get_iter( model, &iter, (GtkTreePath *) selRows[0].data ) )
        {
            gtk_tree_model_get_value( model, &iter, 0, &value );
            gchar *string2 = g_strdup_value_contents( &value );
            g_free( string2 );
        }
    }
    const char *str = g_value_get_string( &value );
    wxString temp = wxGTK_CONV_BACK( g_value_get_string( &value ) );
    page->SetFaceName( temp );
    g_list_free_full( selRows, (GDestroyNotify) gtk_tree_path_free );*/
}
}

#if GTK_CHECK_VERSION(3, 2, 0)
#else
/*static void find_widgets(GtkWidget *view, CFontPropertyPage *page)
{
    if( GTK_IS_CONTAINER( view ) && !GTK_IS_TREE_VIEW( view ) && !GTK_IS_ENTRY( view ) )
        gtk_container_foreach( GTK_CONTAINER( view ), (GtkCallback) find_widgets, page );
    else if( GTK_IS_TREE_VIEW( view ) )
    {
        g_signal_connect( view, "cursor-changed", G_CALLBACK( font_name_change ), page );
        return;
    }
    else if( GTK_IS_ENTRY( view ) )
    {
        g_signal_connect( view, "changed", G_CALLBACK( font_name_change ), page );
        return;
    }
}*/
#endif

#if GTK_CHECK_VERSION(4, 10, 0)
static void on_font_dialog_button_font_desc_notify(GtkFontDialogButton *button, GParamSpec *pspec, gpointer user_data)
{
    // Get the selected font description
    PangoFontDescription *font_desc = gtk_font_dialog_button_get_font_desc( button );

    // You can now use font_desc to update the font of other widgets or
    // perform actions based on the selected font
    g_print( "Selected Font: %s\n", pango_font_description_to_string( font_desc ) );

    // Don't forget to free the font description
    pango_font_description_free( font_desc );
}
#endif

CFontPropertyPage::CFontPropertyPage(wxWindow* parent, FontPropertyPage font, bool colorEnabled)
 : CFontPropertyPageBase(parent, font)
{
    m_font = font;
    m_isUnderlined = m_font.font.GetUnderlined();
    m_isStriken = m_font.font.GetStrikethrough();
    auto fontDesc = font.font.GetNativeFontInfo()->description;
#if GTK_CHECK_VERSION(4, 10, 0)
    GtkFontDialog *dlg = gtk_font_dialog_new();
    m_fontPanel = gtk_font_dialog_button_new( dlg );
    gtk_font_dialog_button_set_font_desc( GTK_FONT_DIALOG_BUTTON( m_fontPanel ), fontDesc );
    g_signal_connect( m_fontPanel, "notify::font-desc", G_CALLBACK( on_font_dialog_button_font_desc_notify ), NULL );
#endif
#if GTK_CHECK_VERSION(3, 2, 0 )
    m_fontPanel = gtk_font_chooser_widget_new();
    gtk_font_chooser_set_font_desc( (GtkFontChooser *) m_fontPanel, fontDesc );
    gtk_font_chooser_set_show_preview_entry( (GtkFontChooser *) m_fontPanel, false );
#else
    m_fontPanel = gtk_font_selection_new();
#endif
    g_object_ref_sink( m_fontPanel );
    m_holder = new wxNativeWindow( this, wxID_ANY, m_fontPanel );
    ResetFont( true );
    m_underline = new wxCheckBox( this, wxID_ANY, _( "Underline" ) );
    m_strikethrough = new wxCheckBox( this, wxID_ANY, _( "Strikethrough" ) );
    m_textColor = new CColorComboBox( this, wxID_ANY );
    m_backColor = new CColorComboBox( this, wxID_ANY );
    m_textColor->SetColourValue( font.text );
    m_backColor->SetColourValue( font.back );
    itemStaticBox1 = new wxStaticBox( this, wxID_ANY, _( "Effects" ) );
    itemStaticBox2 = new wxStaticBox( this, wxID_ANY, _( "Preview" ) );
    m_label1 = new wxStaticText( this, wxID_ANY, _( "Text Color" ) );
    m_label2 = new wxStaticText( this, wxID_ANY, _( "Background Color" ) );
    m_preview = new wxFontPreviewer( this, "AaBbYyZz" );
    if( m_font.font.GetUnderlined() )
        m_underline->SetValue( true );
    if( m_font.font.GetStrikethrough() )
        m_strikethrough->SetValue( true );
    auto sizer_4 = new wxStaticBoxSizer( itemStaticBox1, wxVERTICAL );
    auto sizer_5 = new wxStaticBoxSizer( itemStaticBox2, wxHORIZONTAL );
    auto main = new wxBoxSizer( wxVERTICAL );
    auto sizer1 = new wxBoxSizer( wxHORIZONTAL );
    auto sizer2 = new wxFlexGridSizer( 2, 2, 5, 5 );
    auto sizer3 = new wxBoxSizer( wxHORIZONTAL );
    main->Add( 5, 5, 0, wxEXPAND, 0 );
    main->Add( m_holder, 0, wxEXPAND, 0 );
    main->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_4->Add( m_underline, 0, wxEXPAND, 0 );
    sizer_4->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_4->Add( m_strikethrough, 0, wxEXPAND, 0 );
    sizer3->Add( sizer_4, 0, wxEXPAND, 0 );
    sizer3->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer_5->Add( m_preview, 0, wxEXPAND, 0 );
    sizer3->Add( sizer_5, 1, wxEXPAND, 0 );
    main->Add( sizer3, 1, wxEXPAND, 0 );
    main->Add( 5, 5, 0, wxEXPAND, 0 );
    sizer2->Add( m_label1, 0, wxEXPAND, 0 );
    sizer2->Add( m_label2, 0, wxEXPAND, 0 );
    sizer2->Add( m_textColor, 0, wxEXPAND, 0 );
    sizer2->Add( m_backColor, 0, wxEXPAND, 0 );
    sizer2->AddGrowableCol( 0, 1 );
    sizer2->AddGrowableCol( 1, 1 );
    main->Add( sizer2, 1, wxEXPAND, 0 );
    main->Add( 5, 5, 0, wxEXPAND, 0 );
    SetSizer( main );
    Layout();
    if( colorEnabled )
    {
        m_textColor->Enable( true );
        m_backColor->Enable( true );
    }
    else
    {
        m_textColor->Enable( false );
        m_backColor->Enable( false );
    }
    m_underline->Bind( wxEVT_CHECKBOX, &CFontPropertyPage::OnUnderline, this );
    m_strikethrough->Bind( wxEVT_CHECKBOX, &CFontPropertyPage::OnStrikethrough, this );
}

CFontPropertyPage::~CFontPropertyPage()
{
#if GTK_CHECK_VERSION(4, 10, 0)
    g_object_unref( dlg );
#endif
    m_holder->Disown();
}

void CFontPropertyPage::OnUnderline(wxCommandEvent &event)
{
    if( event.IsChecked() )
    {
        m_isUnderlined = true;
        m_font.font.SetUnderlined( true );
    }
    else
    {
        m_isUnderlined = false;
        m_font.font.SetUnderlined( false );
    }
    ResetFont();
    m_isModified = true;
}

void CFontPropertyPage::OnStrikethrough(wxCommandEvent &event)
{
    if( event.IsChecked() )
    {
        m_isStriken = true;
        m_font.font.SetStrikethrough( true );
    }
    else
    {
        m_isStriken = false;
        m_font.font.SetStrikethrough( false );
    }
    ResetFont();
    m_isModified = true;
}

void CFontPropertyPage::ResetFont(bool init)
{
#if GTK_CHECK_VERSION(3, 2, 0 )
    gtk_font_chooser_set_font_desc( (GtkFontChooser *) m_fontPanel, m_font.font.GetNativeFontInfo()->description );
    gtk_font_chooser_set_preview_text( (GtkFontChooser *) m_fontPanel, "AaBbYyZz" );
    if( init )
        g_signal_connect( m_fontPanel, "notify::font", G_CALLBACK( font_name_change ), this );
#else
    gtk_font_selection_set_font_name( (GtkFontSelection *) m_fontPanel, m_font.font.GetNativeFontInfo()->ToString().c_str() );
    gtk_font_selection_set_preview_text( (GtkFontSelection *) m_fontPanel, "AaBbYyZz" );
    GtkWidget *names = gtk_font_selection_get_family_list( (GtkFontSelection *) m_fontPanel );
    GtkWidget *sizes = gtk_font_selection_get_size_entry( (GtkFontSelection *) m_fontPanel );
//    gtk_container_forall( GTK_CONTAINER( m_fontPanel ), (GtkCallback) find_widgets, this );
#endif
    PangoAttrList* attrs = pango_attr_list_new();
    PangoAttribute* a;

    if( m_isUnderlined )
    {
        a = pango_attr_underline_new( PANGO_UNDERLINE_SINGLE );
        pango_attr_list_insert( attrs, a );
    }
    if( m_isStriken )
    {
        a = pango_attr_strikethrough_new( true );
        pango_attr_list_insert( attrs, a );
    }

//    pango_layout_set_attributes( layout, attrs );
//    pango_attr_list_unref( attrs );
}
#endif
